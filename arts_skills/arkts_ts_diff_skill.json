{
  "name": "ArkTS 与 TypeScript 差异指南",
  "description": "提供 ArkTS 编码规范、最佳实践和常见模式的指导，帮助开发者编写符合规范的 ArkTS 代码。主要用于区别 TypeScript 和 ArkTS 的语法差异，并给出相应的示例代码和迁移建议。",
  "version": "1.2.0",
  "category": "代码编写",
  "tags": [
    "arkts",
    "ets",
    "typescript",
    "编码规范",
    "最佳实践",
    "代码指导",
    "语法差异"
  ],
  "input_schema": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "查询内容（如：如何定义类、如何处理异步、如何使用接口等）"
      },
      "codeSnippet": {
        "type": "string",
        "description": "代码片段（可选，用于代码审查或优化建议）"
      },
      "context": {
        "type": "string",
        "enum": [
          "syntax",
          "types",
          "async",
          "error_handling",
          "best_practices"
        ],
        "description": "上下文类型（可选，用于聚焦特定领域）"
      }
    },
    "required": [
      "query"
    ]
  },
  "steps": [
    {
      "step": 1,
      "name": "理解查询意图",
      "description": "分析用户查询，确定需要提供的指导类型",
      "actions": [
        "分析查询内容",
        "识别查询类型（语法、类型、异步、错误处理等）",
        "确定是否需要代码审查"
      ]
    },
    {
      "step": 2,
      "name": "提供编码规范",
      "description": "根据查询提供相应的 ArkTS 编码规范",
      "topics": {
        "syntax": [
          "类定义和继承",
          "接口实现",
          "方法定义",
          "属性定义",
          "访问修饰符（private, public, protected）",
          "构造函数中不能声明字段（需在类中声明，构造函数中赋值）",
          "对象展开和解构（不支持）",
          "数组解构（部分支持）",
          "参数解构（不支持）",
          "计算属性名（不支持）",
          "for...in 循环（不推荐）"
        ],
        "types": [
          "类型定义",
          "接口定义",
          "泛型使用",
          "联合类型和交叉类型",
          "可选属性",
          "返回类型（不支持 this，需使用具体类名）",
          "索引签名（不支持，需使用 Record 或显式字段）",
          "as const 断言（不支持）",
          "类型断言（支持 as 和 <> 语法）",
          "ESObject 类型使用（通过 ESObject 获取的变量需要显式指定类型）"
        ],
        "async": [
          "async/await 使用",
          "Promise 处理",
          "异步错误处理",
          "异步迭代器（支持）"
        ],
        "error_handling": [
          "try-catch 使用（catch 不支持类型注解）",
          "错误类型处理",
          "错误传播",
          "finally 块使用"
        ],
        "best_practices": [
          "代码组织",
          "注释规范（JSDoc 支持）",
          "命名规范（驼峰命名）",
          "导出规范（推荐具名导出，避免 export *）",
          "性能优化",
          "类型安全（优先使用具体类型，尽量避免 ESObject）",
          "ESObject 使用原则（仅在无法确定类型时使用，优先定义接口或使用具体类型）",
          "ESObject 变量必须显式指定类型",
          "模块化设计"
        ]
      }
    },
    {
      "step": 3,
      "name": "提供代码示例",
      "description": "提供符合规范的代码示例",
      "actions": [
        "提供正确示例",
        "提供错误示例对比",
        "说明原因和注意事项"
      ]
    },
    {
      "step": 4,
      "name": "代码审查（如提供代码）",
      "description": "如果提供了代码片段，进行代码审查",
      "actions": [
        "检查语法合规性",
        "检查类型使用",
        "检查最佳实践",
        "提供优化建议"
      ]
    },
    {
      "step": 5,
      "name": "生成指导报告",
      "description": "生成完整的编码指导报告",
      "actions": [
        "汇总编码规范",
        "提供代码示例",
        "提供常见错误和解决方案",
        "提供相关资源链接"
      ]
    }
  ],
  "coding_rules": {
    "syntax": {
      "object_spread": "不支持对象展开运算符 {...obj}，需手动逐字段赋值",
      "object_destructuring": "不支持对象解构 const {a, b} = obj，需改为 const a = obj.a; const b = obj.b;",
      "as_const": "不支持 as const，需使用显式类型定义或 readonly",
      "computed_property": "不支持计算属性名 {[key]: value}，需使用字面量值",
      "index_signature": "不支持索引签名 [k: string]: any，需改为 Record<string, ESObject> 或最好显式字段",
      "for_in": "推荐使用 for...of Object.keys(obj) 而不是 for...in",
      "export_wildcard": "推荐使用具名导出 export { Name } from './module' 而不是 export * from './module'",
      "constructor_field_declaration": "不支持在构造函数参数中声明字段，需在类中声明字段，然后在构造函数中赋值。例如：❌ constructor(message: string, public readonly timeout: number) { ... } ✅ class TimeoutError { public readonly timeout: number; constructor(message: string, timeout: number) { this.timeout = timeout; } }"
    },
    "types": {
      "return_this": "方法返回值不能使用 this，必须使用具体的类名",
      "catch_type": "catch 语句不支持类型注解，使用 catch (err) 而不是 catch (err: Error)",
      "timer_type": "定时器类型使用 number 而不是 NodeJS.Timeout",
      "const_object": "常量对象应先定义接口，然后赋值，而不是使用 readonly 内联类型",
      "esobject_type_annotation": "通过 ESObject 获取的变量必须显式指定类型，例如：const backtrace: ESObject | undefined = crashData.backtrace; 而不是 const backtrace = crashData.backtrace;",
      "esobject_generic_type": "即使函数泛型已指定 ESObject 类型，变量声明时仍需显式指定类型注解。例如：❌ const crashData = safeJsonParse<ESObject>(crashContent); ✅ const crashData: ESObject = safeJsonParse<ESObject>(crashContent);"
    },
    "async": {
      "async_await": "支持 async/await，用法与 TypeScript 相同",
      "promise_handling": "Promise 处理方式与 TypeScript 相同",
      "error_propagation": "异步错误通过 try-catch 处理"
    },
    "error_handling": {
      "catch_syntax": "catch (err) 而不是 catch (err: Error)",
      "error_type": "统一使用 Error 类型",
      "error_propagation": "错误通过 throw 和 catch 传播",
      "rethrow_error": "catch 到的 error 一定是 Error 类型的子类型，如果再次抛出需要显式转换：throw error as Error，例如：❌ catch (error) { throw error; } ✅ catch (error) { throw error as Error; }",
      "error_log_message": "catch 到的 error 可以直接使用 .message 属性，不需要类型检查。例如：❌ e instanceof Error ? e.message : String(e) ✅ e.message",
      "promise_catch_type": "Promise 的 .catch() 中捕获的 error 也需要显式指定类型，如果不清楚类型就用 Error。例如：❌ .catch((error) => { ... }) ✅ .catch((error: Error) => { ... })"
    },
    "best_practices": {
      "comments": "完整保留所有注释（JSDoc、单行、多行、内联）",
      "naming": "使用清晰的命名，遵循驼峰命名规范",
      "exports": "使用具名导出，明确列出导出的内容",
      "code_organization": "按功能模块组织代码，保持单一职责",
      "type_safety": "优先使用具体类型，尽量避免 ESObject（注意：ArkTS 不支持 any，ESObject 仅作为最后选择）",
      "esobject_avoidance": "尽量不要使用 ESObject，能指定具体类型尽量指定或定义接口。例如：❌ const data: ESObject = JSON.parse(str); ✅ interface CrashData { signal: number; signal_name: string; backtrace?: string[]; } const data: CrashData = JSON.parse(str); 只有在确实无法确定类型时才使用 ESObject",
      "esobject_explicit_type": "如果必须使用 ESObject，变量必须显式指定类型，确保类型安全。包括：1) 从 ESObject 属性获取的变量：❌ const backtrace = crashData.backtrace; ✅ const backtrace: ESObject | undefined = crashData.backtrace; 2) 从泛型函数返回的 ESObject：❌ const crashData = safeJsonParse<ESObject>(crashContent); ✅ const crashData: ESObject = safeJsonParse<ESObject>(crashContent);"
    }
  },
  "examples": [
    {
      "input": {
        "query": "如何在 ArkTS 中定义类和方法？",
        "context": "syntax"
      },
      "description": "查询类和方法定义规范"
    },
    {
      "input": {
        "query": "如何处理异步操作？",
        "context": "async"
      },
      "description": "查询异步处理方式"
    },
    {
      "input": {
        "codeSnippet": "class Builder {\n  setName(name: string): this {\n    return this;\n  }\n}",
        "query": "这段代码有什么问题？"
      },
      "description": "代码审查示例"
    },
    {
      "input": {
        "query": "如何定义常量对象？",
        "context": "types"
      },
      "description": "查询常量对象定义方式"
    }
  ]
}